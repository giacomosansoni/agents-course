# Tools
<!-- Discussion on Pydantic tools, conversion to string in the system prompt, and other common tool formats. -->
<!-- TODO: @jofthomas -->
This page provides an overview of AI tools and how they can be integrated into AI agents.

One crucial aspect of AI agents is their ability to take **actions**. Tools exist in order to enhance the capabilities of the LLM and to accomplish a wider range of tasks.


## What are AI tools?

A good tool should be something that complements the power of an LLM. For instance if you need to perform calculus, giving a **calculator tool** to your LLM will provide better result than relying on the native capacities of the model.
Furthermore, LLM predict the completion of a prompt based on their training data. Which means that it's internal knowledge only cover events that happened before their training.

Tools are executable code that the agent can use to perform specific tasks. These tasks might include extracting information from databases, search internet, generate images, or anything else the agent needs to do to complete a task.

- A Tool is a reusable piece of code that contains:
  - A textual description of what the function does.
  - A Callable (something to perform an action).
  - Arguments with typings.

Let's understand Tools through a fictionnal example ( that is close to the real implementation in most library):

```python
class Tool:
    """
    A class representing a reusable piece of code (Tool).
    
    Attributes:
        name (str): Name of the tool.
        description (str): A textual description of what the tool does.
        func (callable): The function or callable that this tool wraps.
        arguments (list): A list of (argument_name, annotation) for each argument.
        outputs (str or list): The return type(s) of the wrapped function.
    """
    def __init__(self, 
                 name: str, 
                 description: str, 
                 func: callable, 
                 arguments: list,
                 outputs: str):
        self.name = name
        self.description = description
        self.func = func
        self.arguments = arguments
        self.outputs = outputs

    def to_string(self) -> str:
        """
        Return a string representation of the tool, 
        including its name, description, arguments, and outputs.
        """
        args_str = ", ".join([
            f"{arg_name}: {arg_type}" for arg_name, arg_type in self.arguments
        ])
        
        return (
            f"Tool Name: {self.name}\n"
            f"Description: {self.description}\n"
            f"Arguments: {args_str}\n"
            f"Outputs: {self.outputs}"
        )

    def __call__(self, *args, **kwargs):
        """
        Invoke the underlying function (callable) with provided arguments.
        """
        return self.func(*args, **kwargs)
```
<details>
<summary>Click to expand code</summary>

```python
def tool(func):
    """
    A decorator that creates a Tool instance from the given function.
    """
    # Get the function signature
    signature = inspect.signature(func)
    
    # Extract (param_name, param_annotation) pairs for inputs
    arguments = []
    for param in signature.parameters.values():
        annotation_name = (
            param.annotation.__name__ 
            if hasattr(param.annotation, '__name__') 
            else str(param.annotation)
        )
        arguments.append((param.name, annotation_name))
    
    # Determine the return annotation
    return_annotation = signature.return_annotation
    if return_annotation is inspect._empty:
        outputs = "No return annotation"
    else:
        outputs = (
            return_annotation.__name__ 
            if hasattr(return_annotation, '__name__') 
            else str(return_annotation)
        )
    
    # Use the function's docstring as the description (default if None)
    description = func.__doc__ or "No description provided."
    
    # The function name becomes the Tool name
    name = func.__name__
    
    # Return a new Tool instance
    return Tool(
        name=name, 
        description=description, 
        func=func, 
        arguments=arguments, 
        outputs=outputs
    )
```
</details>


tool:
```python
@tool
def calculator(a: int, b: int) -> int:
    """Multiply two integers."""
    return a * b

print(calculator.to_string())
```
Output :
```
Tool Name: calculator
Description: Multiply two integers.
Arguments: a: int, b: int
Outputs: int
```
```python
result = calculator(5, 6)
print(f"Call result: {result}")
```
Output :
```
Call result: 30
```
## Interface Design for Tools

The design of the interface through which an agent uses tools can affect the agent's performance. For example, a search tool that returns results **ordered by relevance** may be more helpful to an AI agent than one that returns results **ordered by frequency**. The interface should be designed to be clear and concise, so that the agent can easily understand how to use the tools. It should also be designed to be flexible, so that the agent can use the tools in different ways depending on the task at hand.

Here are some examples of how interface design can affect an AI agent's performance:

*   **Structured Output:** Providing a specific format or schema for the AI to follow in its response can help the agent to use tools more effectively. For example, if the agent is using a tool to retrieve data from a database, the interface should specify the format in which the data should be returned.
*   **Tool Descriptions:** Providing clear and concise descriptions of the tools can help the agent to understand how to use them. The descriptions should include information about the tool's purpose, its inputs and outputs, and any limitations.
*   **Tool Selection:** The interface should make it easy for the agent to select the appropriate tool for the task at hand. This could involve providing a list of tools or a search function.
*   **Feedback:** The interface should provide feedback to the agent on the results of its tool use. This could involve displaying the output of the tool or providing an error message if the tool fails.

## Tool Use as Action

The use of tools is considered a form of "acting" by an AI agent in an environment. Agents can generate special tokens to invoke tool calls. This "acting" can be guided by "reasoning," which allows the agent to plan and re-plan based on the information gained from the tool. For example, an agent might use a search engine to find information and then use a calculator to perform calculations based on that information. The agent may revise its plan based on the result of the calculation and return the retrieved information. This kind of reasoning-based tool use is the cornerstone of agents, and we will explore it in more detail in the coming sections.

## Conclusion

AI tools play a crucial role in enhancing the capabilities of AI agents. By effectively utilizing these tools, AI agents can perform complex tasks, reason through problems, and interact with users in a more sophisticated and dynamic manner. As the field of AI agents continues to evolve, we can expect to see even more innovative and powerful tools being developed and integrated into these systems.

## Pop Quiz üçæ

1. Which of the following best describes an AI tool?

   A. A process that only generates text responses  
   B. An executable process or external API that allows agents to perform specific tasks and interact with external environments  
   C. A feature that stores agent conversations  

2. Which interface design principle enhances an AI agent's ability to use tools effectively?

   A. Displaying all tool outputs in random formats  
   B. Providing clear descriptions, structured output formats, and feedback mechanisms  
   C. Limiting tool descriptions to technical specifications only  

3. How do AI agents use tools as a form of "acting" in an environment?

   A. By passively waiting for user instructions  
   B. By only using pre-programmed responses  
   C. By generating tokens to invoke tools and revising plans based on the information gained  

---
<details>
<summary>Answer Key (click to reveal)</summary>

1. B. An executable process or external API that allows agents to perform specific tasks and interact with external environments

   ‚Ä¢ Explanation: The text defines tools as executable processes or external APIs that agents use to perform specific tasks and interact with external environments.

2. B. Providing clear descriptions, structured output formats, and feedback mechanisms

   ‚Ä¢ Explanation: The interface design section emphasizes the importance of structured output, clear tool descriptions, tool selection, and feedback mechanisms.

3. C. By generating tokens to invoke tools and revising plans based on the information gained

   ‚Ä¢ Explanation: The text explains that agents can generate special tokens to invoke tools and use reasoning to plan and re-plan based on the information gained.

</details>

