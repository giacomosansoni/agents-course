# Messages and Special Tokens

In this section we will explore how Large Language Models (LLMs) structure their generations through **tokenization**, **special tokens**, and **chat-templates**.

You have understood in the previous section that all LLMs have different EOS token. But this is not in fact no the only difference from one LLM to another. Each LLM have it's own way to format prompt.

Also up untill now we only talked about **Prompt** which are the tokens that goes as an input of your LLM. A prompt is universal for every LLM, they take a prompt as an input and complete the sequence with contextually probable words. 

> **Q**: But ... When, I'm interacting with chatGPT/Hugging Chat, I'm having a conversation in Messages, not prompts
>
> **A**: This is correct ! But this in fact mostly a UI thing. When fed into the LLM, the messages are concatenated back into a prompt.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/assistant.jpg" alt="Behind models"/>

## Messages

### System Messages

System messages (also called system prompt) set the foundation for how the model should behave. They act as persistent instructions that influence all subsequent interactions. For example:

```python
system_message = {
    "role": "system",
    "content": "You are a professional customer service agent. Always be polite, clear, and helpful."
}
```

In Agents, the Message Prompt allows **to store the information about available tools**, provide instructions to the model on how to format the actions to take, and guide the overall guidelines of how the thought process should be segmented.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/alfred-systemprompt.jpg" alt="Alfred System Prompt"/>


### Conversations : User and Assistant Message

A conversation consist in alternating messages betwen a Human ( user ) and an LLM ( assistant )

Chat templates maintain context through conversation history, storing previous exchanges between users and the assistant. This allows for more coherent multi-turn conversations:

```python
conversation = [
    {"role": "user", "content": "I need help with my order"},
    {"role": "assistant", "content": "I'd be happy to help. Could you provide your order number?"},
    {"role": "user", "content": "It's ORDER-123"},
]
```

Templates can handle complex multi-turn conversations while maintaining context:

```python
messages = [
    {"role": "system", "content": "You are a math tutor."},
    {"role": "user", "content": "What is calculus?"},
    {"role": "assistant", "content": "Calculus is a branch of mathematics..."},
    {"role": "user", "content": "Can you give me an example?"},
]
```

## Tokenization

We already talked a little bit about tokenization, but we only talked about the most prominant kinf of tokenization (**Subword Tokenization**), hence let's do a deeper dive.

Tokenization is the process of breaking down a text into smaller units, called tokens. These tokens are then used to represent the text in a way that can be processed by the model. For a detailed explanation, see the 

For natural language, tokens are frequently appearing combinations of characters within a language. 

Tokenizers are crucial in preparing inputs for models. They convert text into a format that models can understand, typically by splitting text into sub-word units and converting these into numerical IDs. Hugging Face provides two types of tokenizers: a full Python implementation and a "Fast" implementation based on the Rust library ðŸ¤— Tokenizers. The "Fast" tokenizers offer significant speed improvements and additional methods for mapping between the original text and token space.

### Types of Tokenization

1. **Word Tokenization**: This involves splitting text into individual words. It's simple but can be inefficient for languages with complex morphology.

2. **Subword Tokenization**: This breaks down words into smaller units, such as prefixes, suffixes, or even individual characters. This method is more efficient for handling rare words and is commonly used in modern NLP models.

3. **Character Tokenization**: This splits text into individual characters. While it can handle any text, it often results in longer sequences, which can be computationally expensive.

### Importance of Tokenization

- **Efficiency**: Tokenization reduces the complexity of text data, making it easier for models to process.
- **Handling Rare Words**: Subword tokenization helps in managing rare or unseen words by breaking them into known subword units.
- **Language Agnostic**: Tokenization can be adapted to different languages, making it versatile for multilingual models.

## Chat-Templates

Chat templates are essential for structuring interactions between language models and users. They provide instruction to format message conversations into prompt.

### Base Models vs Instruct Models

A base model is trained on raw text data to predict the next token, while an instruct model is fine-tuned specifically to follow instructions and engage in conversations. For example, `SmolLM2-135M` is a base model, while `SmolLM2-135M-Instruct` is its instruction-tuned variant.

To make a base model behave like an instruct model, we need to format our prompts in a consistent way that the model can understand. This is where chat templates come in. ChatML is one such template format that structures conversations with clear role indicators (system, user, assistant). If you have interacted with some AI API lately, you know that's the standard practice.

It's important to note that a base model could be fine-tuned on different chat templates, so when we're using an instruct model we need to make sure we're using the correct chat template. 

Here is an example :

```python
messages = [
    {"role": "system", "content": "You are a helpful assistant focused on technical topics."},
    {"role": "user", "content": "Can you explain what a chat template is?"},
    {"role": "assistant", "content": "A chat template structures conversations between users and AI models..."}
]
```

### Understanding Chat Templates

Each model having different special token, chat templates have be implemented to ensure that we correctly format the prompt in each model. 

Chat templates include Jinj2 code on how to transform the ChatML list of JSON messages presented in the above example into a textual representation of the system-level instructions, user messages and assistant responses that the model can understand.

This structure helps maintain consistency across interactions and ensures the model responds appropriately to different types of inputs.Below is an example of a chat template:

chat_template of `SmolLM2-135M-Instruct`:
```jinja2
{% for message in messages %}
{% if loop.first and messages[0]['role'] != 'system' %}
<|im_start|>system
You are a helpful AI assistant named SmolLM...
<|im_end|>
{% endif %}
<|im_start|>{{ message['role'] }}
{{ message['content'] }}<|im_end|>
{% endfor %}
```
As you can see a chat_template is some code that will write how should the list of messages be formated inside 

```sh
<|im_start|>user
Hi there!<|im_end|>
<|im_start|>assistant
Nice to meet you!<|im_end|>
<|im_start|>user
Can I ask a question?<|im_end|>
<|im_start|>assistant
```

If you remember last lesson, you will notice that "<|im_end|>" is the End of sequence ( EOS ) token of **SmolLM2-135M-Instruct**. Meaning that we only ask the assistant to generate some part of it ( in this case the assistant messages )

The `transformers` library will take care of chat templates for you in relation to the model's tokenizer. Read more about how transformers builds chat templates [here](https://huggingface.co/docs/transformers/en/chat_templating#how-do-i-use-chat-templates). All we have to do is structure our messages in the correct way and the tokenizer will take care of the rest.

Or you can experiment with different conversations/models to see how they are then formated for the model in the following space :
<iframe
	src="https://jofthomas-chat-template-viewer.hf.space"
	frameborder="0"
	width="850"
	height="450"
></iframe>


### Tool Usage

Tool usage in chat templates allows models to interact with external functions and APIs in a structured way. AI agents rely on tools to perform tasks, such as searching the web, performing calculations, or even controlling physical robots. 

When working with tools, chat templates need to handle three specific message types: 

- *Tool definitions* that describe available functions, 
- *Tool calls* that occur when the assistant wants to use a tool, 
- *Tool responses* that contain results returned from tool execution.

Here's an example of how a tool interaction might look in a chat template:

```sh
<|im_start|>system
You are an AI assistant with access to a calculator tool.<|im_end|>
<|im_start|>user
What is 123 multiplied by 456?<|im_end|>
<|im_start|>tool
Tool Name: calculator
Tool Arguments: {"operation": "multiply", "x": 123, "y": 456}<|im_end|>
<|im_start|>tool-answer
Tool Answer : 56,088
<|im_start|>assistant
Based on the calculator tool, 123 multiplied by 456 equals 56,088.<|im_end|>
```

This example shows how special tokens (`<|im_start|>` and `<|im_end|>`) are used to segment different parts of the conversation, including system context, user input, tool usage, and the assistant's response. Let's see it in action with an example conversation:

```python
messages = [
    {"role": "system", "content": "You are an AI assistant with access to various tools."},
    {"role": "user", "content": "What's the weather in Paris?"},
    {"role": "tool", "tool_name": "WeatherAPI", "args": {"location": "Paris"}},
    {"role": "assistant", "content": "It's currently 20Â°C and partly cloudy."},
]
```

To use this template with your model, you'll need to ensure your model is trained to work with tool calls in this format. Then, configure your tokenizer with the appropriate chat template. Finally, use the template to format messages before sending to the model:

```python
rendered_prompt = tokenizer.apply_chat_template(messages, tokenize=False)
```

Remember that different models may expect different formatting for tool interactions. Always check your model's documentation for the specific format it expects. The template shown here uses a common format with `<|im_start|>` and `<|im_end|>` tokens, but your model might use different special tokens or formatting.


<!-- Todo add transition -->

## Resources

- [Hugging Face Chat Templating Guide](https://huggingface.co/docs/transformers/main/en/chat_templating)
- [Transformers Documentation](https://huggingface.co/docs/transformers)

