# What are Tools?
<!-- Discussion on Pydantic tools, conversion to string in the system prompt, and other common tool formats. -->
<!-- TODO: @jofthomas -->

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/toolbox.jpg" alt="Toolbox"/>

One crucial aspect of AI agents is their ability to take **actions**. Tools exist in order to enhance the capabilities of the LLM and to accomplish a wider range of tasks. We'll see in this section how AI Tools can be integrated into Agents.

## What are AI Tools?

A **Tool is a function given to the LLM**. This function should fulfill a **clear objective**

Here are some commonly used tools in AI agents :

| Tool            | Description                                                   |
|----------------|---------------------------------------------------------------|
| Web Search     | Allows the agent to fetch up-to-date information from the internet. |
| Image Generation | Creates images based on text descriptions.                  |
| Retrieval      | Retrieves information from an external source.                |
| API Interface  | Interacts with an external API (GitHub, YouTube, Spotify, etc.). |

Those are only examples, as you can in fact create a tool for any use case!

A good tool should be something that **complements the power of an LLM**. For instance if you need to perform calculus, giving a **calculator tool** to your LLM will provide better result than relying on the native capacities of the model.

Furthermore, **LLM predict the completion of a prompt based on their training data**. Which means that it's internal knowledge only cover events that happened before their training, showcasing the need to get access to up to date data through tools.

For instance, using a LLM to give you the today weather without having a web search tool, the LLM will hallucinate by giving you random weather.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/weather.jpg" alt="Weather"/>

- A Tool should contain:

  - A **textual description of what the function does**.
  - A *Callable* (something to perform an action).
  - *Arguments* with typings.
  - (Optional) Outputs with typings.

## How do we give tools to an LLM ?

The answer might be a bit overwhelming, but we simply provide textual descriptions of all the tools available for the model to use in the system prompt.

Here is dummy example:

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/Agent_system_prompt.png" alt="System prompt for tools"/>

The key here is to ensure the most accurate textual description of:

1. **What does this tool do?**
2. **What inputs does it expect?**

If that feels too theoretical, let's understand it through a concrete example:

> **Disclaimer:** This example implementation is fictional but closely resembles real implementations in most libraries.

```python
class Tool:
    """
    A class representing a reusable piece of code (Tool).
    
    Attributes:
        name (str): Name of the tool.
        description (str): A textual description of what the tool does.
        func (callable): The function this tool wraps.
        arguments (list): A list of argument.
        outputs (str or list): The return type(s) of the wrapped function.
    """
    def __init__(self, 
                 name: str, 
                 description: str, 
                 func: callable, 
                 arguments: list,
                 outputs: str):
        self.name = name
        self.description = description
        self.func = func
        self.arguments = arguments
        self.outputs = outputs

    def to_string(self) -> str:
        """
        Return a string representation of the tool, 
        including its name, description, arguments, and outputs.
        """
        args_str = ", ".join([
            f"{arg_name}: {arg_type}" for arg_name, arg_type in self.arguments
        ])
        
        return (
            f"Tool Name: {self.name},"
            f" Description: {self.description},"
            f" Arguments: {args_str},"
            f" Outputs: {self.outputs}"
        )

    def __call__(self, *args, **kwargs):
        """
        Invoke the underlying function (callable) with provided arguments.
        """
        return self.func(*args, **kwargs)
```
This is the Python implementation of the tool we just discussed.  

It may seem complicated, but it's not. We simply define a **`Tool`** class that includes:

- **`name`** (*str*): The name of the tool.  
- **`description`** (*str*): A brief description of what the tool does.  
- **`function`** (*callable*): The function the tool executes.  
- **`input_arguments`** (*list*): The expected input parameters.  
- **`outputs`** (*str* or *list*): The expected outputs of the tool.  
- **`__call__()`**: Calls the function directly when the tool instance is invoked.  
- **`to_string()`**: Converts the tool's attributes into a textual representation.  

Now let's create a Tool.

> For those interested, here’s the code to declare a Tool using a decorator.
<details>
<summary> decorator code</summary>

```python
def tool(func):
    """
    A decorator that creates a Tool instance from the given function.
    """
    # Get the function signature
    signature = inspect.signature(func)
    
    # Extract (param_name, param_annotation) pairs for inputs
    arguments = []
    for param in signature.parameters.values():
        annotation_name = (
            param.annotation.__name__ 
            if hasattr(param.annotation, '__name__') 
            else str(param.annotation)
        )
        arguments.append((param.name, annotation_name))
    
    # Determine the return annotation
    return_annotation = signature.return_annotation
    if return_annotation is inspect._empty:
        outputs = "No return annotation"
    else:
        outputs = (
            return_annotation.__name__ 
            if hasattr(return_annotation, '__name__') 
            else str(return_annotation)
        )
    
    # Use the function's docstring as the description (default if None)
    description = func.__doc__ or "No description provided."
    
    # The function name becomes the Tool name
    name = func.__name__
    
    # Return a new Tool instance
    return Tool(
        name=name, 
        description=description, 
        func=func, 
        arguments=arguments, 
        outputs=outputs
    )
```
</details>

One of the most common tools in most demos is the **calculator** tool.  
Here, we present a simplified version that only multiplies two integers.  

#### **Function Inputs**  
- **`a`** (*int*): An integer.  
- **`b`** (*int*): An integer.  

#### **Returns**  
- (*int*): The product of `a` and `b`.  

We have provided a textual description of this function as a **docstring**,  
so let’s see what it looks like as a **textual description**!  

> **Reminder:** This textual description is *what we want the LLM to know about the tool*.

```python
@tool
def calculator(a: int, b: int) -> int:
    """Multiply two integers."""
    return a * b

print(calculator.to_string())
```
Outputs the following text :
```python
Tool Name: calculator, Description: Multiply two integers., Arguments: a: int, b: int, Outputs: int
```
Based on this Textual description, the LLM knows that it it can call the LLM  `calculator(a, b)`.

Let's just **sanity check** the tool is properly working outside of an agent
```python
result = calculator(5, 6)
print(f"Call result: {result}")
```
Output :
```
Call result: 30
```

The function is perfectly working and we have provided an implementation that allows the Agent to textually know what tools it has at it's disposal. We learn more how an Agent can now **Call* this tool itself in the Actions section

The descr is then **injected** in the system prompt. Taking the same dummy example, here is what it would likle after replacing the variable:
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/Agent_system_prompt_tools.png" alt="System prompt for tools"/>

## Interface Design for Tools

The design of the interface through which an agent uses tools can affect the agent's performance. For example, a search tool that returns results **ordered by relevance** may be more helpful to an AI agent than one that returns results **ordered by frequency**. The interface should be designed to be clear and concise, so that the agent can easily understand how to use the tools. It should also be designed to be flexible, so that the agent can use the tools in different ways depending on the task at hand.

Here are some examples of how interface design can affect an AI agent's performance:

*   **Structured Output:** Providing a specific format or schema for the AI to follow in its response can help the agent to use tools more effectively. For example, if the agent is using a tool to retrieve data from a database, the interface should specify the format in which the data should be returned.
*   **Tool Descriptions:** Providing clear and concise descriptions of the tools can help the agent to understand how to use them. The descriptions should include information about the tool's purpose, its inputs and outputs, and any limitations.
*   **Tool Selection:** The interface should make it easy for the agent to select the appropriate tool for the task at hand. This could involve providing a list of tools or a search function.
*   **Feedback:** The interface should provide feedback to the agent on the results of its tool use. This could involve displaying the output of the tool or providing an error message if the tool fails.

## Tool Use as Action

The use of tools is considered a form of "acting" by an AI agent in an environment. Agents can generate special tokens to invoke tool calls. This "acting" can be guided by "reasoning," which allows the agent to plan and re-plan based on the information gained from the tool. For example, an agent might use a search engine to find information and then use a calculator to perform calculations based on that information. The agent may revise its plan based on the result of the calculation and return the retrieved information. This kind of reasoning-based tool use is the cornerstone of agents, and we will explore it in more detail in the coming sections.


AI Tools play a crucial role in enhancing the capabilities of AI agents. By effectively utilizing these tools, AI agents can perform complex tasks, reason through problems, and interact with users in a more sophisticated and dynamic manner. As the field of AI agents continues to evolve, we can expect to see even more innovative and powerful tools being developed and integrated into these systems.

